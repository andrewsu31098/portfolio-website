/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: scribbletoad (https://sketchfab.com/scribbletoad)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/hand-low-poly-d6c802a74a174c8c805deb20186d1877
title: Hand (low poly)
*/

import * as THREE from "three";
import React, { useRef, useEffect } from "react";
import { useGLTF, Stage } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { Float32BufferAttribute, MeshBasicMaterial } from "three";
import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";
import GUI from "lil-gui";

function onClick(e) {
  console.log(e);
}

export default function Hand(props) {
  // SETUP
  const state = useThree();
  const mesh = useRef(null);
  const { nodes, materials } = useGLTF("hand_low_poly/scene.gltf");
  let handGeo = nodes.Object_5.geometry;
  handGeo.center();

  const tessellateModifier = new TessellateModifier(10, 8);
  handGeo = tessellateModifier.modify(handGeo);

  // GUI
  const gui = new GUI();
  useEffect(() => {
    if (mesh.current) {
      gui.add(mesh.current.position, "x", -300, 300);
      gui.add(mesh.current.position, "y", -300, 300);
      gui.add(mesh.current.position, "z", -300, 300);
      gui.add(mesh.current.rotation, "x", 0, 2 * Math.PI);
      gui.add(mesh.current.rotation, "y", 0, 2 * Math.PI);
      gui.add(mesh.current.rotation, "z", 0, 2 * Math.PI);
    }
  }, [mesh]);

  useEffect(() => {
    console.log(mesh);
  });
  // TESSELLATION CODE

  // TEST

  const numFaces = handGeo.attributes.position.count / 3;
  let origins = handGeo.attributes.position.clone();
  let m = new THREE.Matrix4();
  m.set(1, 0, 0, -90, 0, 1, 0, -20, 0, 0, 1, -70, 0, 0, 0, 1);
  origins.applyMatrix4(m);

  // END TEST

  // const numFaces = handGeo.attributes.position.count / 3;
  const colors = new Float32Array(numFaces * 3 * 3);
  const displacement = new Float32Array(numFaces * 3 * 3);
  const faceNormals = new Float32Array(numFaces * 3 * 3);
  const planeIndex = new Int32Array(numFaces * 3);

  for (let f = 0; f < numFaces; f++) {
    const index = 9 * f;

    // Calculate random displacement.
    const d = 1 * ((1 - Math.random()) / 2);

    // Calculate for face normals.
    var normalRef = handGeo.attributes.normal.array;
    const a = new THREE.Vector3(
      normalRef[index],
      normalRef[index + 1],
      normalRef[index + 2]
    );
    const b = new THREE.Vector3(
      normalRef[index + 3],
      normalRef[index + 4],
      normalRef[index + 5]
    );
    const c = new THREE.Vector3(
      normalRef[index + 6],
      normalRef[index + 7],
      normalRef[index + 8]
    );

    var normalVector = new THREE.Vector3(
      parseFloat(a.x + b.x + c.x),
      parseFloat(a.y + b.y + c.y),
      parseFloat(a.z + b.z + c.z)
    );
    normalVector.divideScalar(3.0);
    normalVector.normalize();

    for (let i = 0; i < 3; i++) {
      colors[index + 3 * i] = 0.96078;
      colors[index + 3 * i + 1] = 0.96078;
      colors[index + 3 * i + 2] = 0.96078;

      //  Changed to black for testing.
      // colors[index + 3 * i] = 0.12157;
      // colors[index + 3 * i + 1] = 0.31765;
      // colors[index + 3 * i + 2] = 1.0;

      displacement[index + 3 * i] = d;
      displacement[index + 3 * i + 1] = d;
      displacement[index + 3 * i + 2] = d;

      // Away and up. Negative x, y, positive z.
      faceNormals[index + 3 * i] = normalVector.x;
      faceNormals[index + 3 * i + 1] = normalVector.y;
      faceNormals[index + 3 * i + 2] = normalVector.z;

      planeIndex[3 * f + i] = f;
    }
  }

  handGeo.setAttribute(
    "displacement",
    new THREE.BufferAttribute(displacement, 3)
  );
  handGeo.setAttribute("customColor", new THREE.BufferAttribute(colors, 3));
  handGeo.setAttribute("faceNormal", new THREE.BufferAttribute(faceNormals, 3));
  handGeo.setAttribute("planeIndex", new THREE.BufferAttribute(planeIndex, 1));
  handGeo.setAttribute("origin", new THREE.BufferAttribute(origins.array, 3));

  let uniforms = {
    amplitude: { value: 0 },
  };

  const vertilla = `
uniform float amplitude;

attribute vec3 customColor;
attribute vec3 displacement;
attribute vec3 faceNormal;

attribute int planeIndex;
attribute vec3 origin;



varying vec3 vNormal;
varying vec3 vColor;

void main() {

    vNormal = normal;
    vColor = customColor;
    float fplaneIndex = float(planeIndex);

    vec3 newPosition;
    vec3 originVector = position - origin;
    originVector = normalize(originVector);
    
    newPosition = position + faceNormal  * displacement;

    // if (fplaneIndex <= amplitude && (amplitude-fplaneIndex <= 115.0)) {
    //   newPosition = position - originVector * (amplitude-fplaneIndex)  ;
    // }
    // else if (amplitude-fplaneIndex > 115.0){
    //   newPosition = position - originVector * 115.0;
    // }
    // else {
    //   newPosition = position;
    // }
    // if (fplaneIndex >= 447.0 && fplaneIndex < 565.0) {
    //   newPosition = position + faceNormal * amplitude * displacement;
    // }
    // else {
    //         newPosition = position + faceNormal * amplitude * displacement;
    // }

    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
}
`;

  const fraglon = `
varying vec3 vNormal;
varying vec3 vColor;

void main() {

    const float ambient = 0.4;

    vec3 light = vec3( 1.0 );
    light = normalize( light );

    float directional = max( dot( vNormal, light ), 0.0 );

    gl_FragColor = vec4( ( directional + ambient ) * vColor, 1.0 );


}
`;

  const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertilla,
    fragmentShader: fraglon,
    side: THREE.DoubleSide,
    wireframe: props.wireframe ? true : false,
    transparent: true,
  });

  function render() {
    //MAIN START
    const time = Date.now() * 0.001;
    uniforms.amplitude.value = 200.0 + 200 * Math.sin(time * 2);
    // uniforms.amplitude.value += 1.0;
    // mesh.current.rotation.y += 0.001;
    // mesh.current.rotation.x += 0.001;
    // mesh.current.rotation.y += 0.01;

    // uniforms.amplitude.value = 50 * Math.sin(time * 0.5);
    // mesh.current.rotation.y = Math.PI * Math.sin(time * 0.5);
  }

  // function animate() {
  //   window.requestAnimationFrame(animate);
  //   render();
  // }
  // useEffect(() => animate(), []);

  useFrame(render);

  return (
    // <Stage contactShadow={{ resolution: 1024, scale: 10 }}>
    <group scale={0.1} onClick={onClick}>
      <mesh
        ref={mesh}
        // Position Z is offset 100. Origins is z-100;
        position={[20, -18.6, -18.6]}
        rotation={[3.1, 2.2, 6.11]}
        geometry={handGeo}
        material={shaderMaterial}
      >
        <axesHelper args={[2, 2, 2]} />
        {/* <meshPhongMaterial attach="material" color="#D3D3D3" /> */}
      </mesh>
    </group>
    // </Stage>
  );
}
