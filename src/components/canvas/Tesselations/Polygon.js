/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: scribbletoad (https://sketchfab.com/scribbletoad)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/hand-low-poly-d6c802a74a174c8c805deb20186d1877
title: Hand (low poly)
*/

import * as THREE from "three";
import * as TWEEN from "@tweenjs/tween.js";
import React, { useRef, useEffect } from "react";
import { useGLTF, Stage } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import {
  Float32BufferAttribute,
  MeshBasicMaterial,
  SphereGeometry,
  IcosahedronGeometry,
  BoxGeometry,
  CylinderGeometry,
} from "three";
import { TessellateModifier } from "three/addons/modifiers/TessellateModifier.js";
import GUI from "lil-gui";
import { generateUUID } from "three/src/math/MathUtils";

function onClick(e) {
  console.log(e);
}

export default function Polygon(props) {
  // SETUP
  const mesh = useRef(null);
  const mesh2 = useRef(null);
  const mesh3 = useRef(null);

  useEffect(() => {
    const rotationTween = new TWEEN.Tween({ y: 0 })
      .to({ y: 4 * Math.PI }, 5000)
      .onUpdate((coords) => {
        mesh.current.rotation.y = coords.y;
      })
      .easing(TWEEN.Easing.Elastic.In);

    // const tesselationTween = new TWEEN.Tween({ amplitude: -1 }).to(
    //   { amplitude: -1 },
    //   4600
    // );
    const tesselationTween2 = new TWEEN.Tween({ amplitude: -1 })
      .to({ amplitude: 0.05 }, 500)
      .onUpdate((coords) => {
        uniforms.amplitude.value = coords.amplitude;
      })
      .easing(TWEEN.Easing.Exponential.Out);

    rotationTween.chain(tesselationTween2);
    rotationTween.start();
    // tesselationTween.start();
  }, []);

  const { nodes, materials } = useGLTF("hand_low_poly/scene.gltf");
  let handGeo = nodes.Object_5.geometry;
  handGeo.center();

  const tessellateModifier = new TessellateModifier(10, 8);
  handGeo = tessellateModifier.modify(handGeo);

  let sphereGeo = new IcosahedronGeometry(1);
  sphereGeo = tessellateModifier.modify(sphereGeo);

  let usedGeo = sphereGeo;

  // GUI
  const gui = new GUI();
  useEffect(() => {
    if (mesh.current) {
      gui.add(mesh.current.position, "x", -5, 5);
      gui.add(mesh.current.position, "y", -5, 5);
      gui.add(mesh.current.position, "z", -5, 5);

      gui.add(uniforms.amplitude, "value", -1, 20);
    }
  }, [mesh]);

  useEffect(() => {
    console.log(mesh);
  });
  // TESSELLATION CODE

  // TEST

  const numFaces = usedGeo.attributes.position.count / 3;
  let origins = usedGeo.attributes.position.clone();
  let m = new THREE.Matrix4();
  m.set(1, 0, 0, -90, 0, 1, 0, -20, 0, 0, 1, -70, 0, 0, 0, 1);
  origins.applyMatrix4(m);

  // END TEST

  // const numFaces = handGeo.attributes.position.count / 3;
  const colors = new Float32Array(numFaces * 3 * 3);
  const displacement = new Float32Array(numFaces * 3 * 3);
  const faceNormals = new Float32Array(numFaces * 3 * 3);
  const planeIndex = new Int32Array(numFaces * 3);

  for (let f = 0; f < numFaces; f++) {
    const index = 9 * f;

    // Calculate random displacement.
    const d = 1 * ((1 - Math.random()) / 2);

    // Calculate for face normals.
    var normalRef = usedGeo.attributes.normal.array;
    const a = new THREE.Vector3(
      normalRef[index],
      normalRef[index + 1],
      normalRef[index + 2]
    );
    const b = new THREE.Vector3(
      normalRef[index + 3],
      normalRef[index + 4],
      normalRef[index + 5]
    );
    const c = new THREE.Vector3(
      normalRef[index + 6],
      normalRef[index + 7],
      normalRef[index + 8]
    );

    var normalVector = new THREE.Vector3(
      parseFloat(a.x + b.x + c.x),
      parseFloat(a.y + b.y + c.y),
      parseFloat(a.z + b.z + c.z)
    );
    normalVector.divideScalar(3.0);
    normalVector.normalize();

    for (let i = 0; i < 3; i++) {
      colors[index + 3 * i] = 0.1;
      colors[index + 3 * i + 1] = 0.1;
      colors[index + 3 * i + 2] = 0.1;

      //  Changed to black for testing.
      // colors[index + 3 * i] = 0.56078;
      // colors[index + 3 * i + 1] = 0.98824;
      // colors[index + 3 * i + 2] = 1;

      // colors[index + 3 * i] = 0.19608;
      // colors[index + 3 * i + 1] = 0.19608;
      // colors[index + 3 * i + 2] = 1;

      displacement[index + 3 * i] = d;
      displacement[index + 3 * i + 1] = d;
      displacement[index + 3 * i + 2] = d;

      // Away and up. Negative x, y, positive z.
      faceNormals[index + 3 * i] = normalVector.x;
      faceNormals[index + 3 * i + 1] = normalVector.y;
      faceNormals[index + 3 * i + 2] = normalVector.z;

      planeIndex[3 * f + i] = f;
    }
  }

  usedGeo.setAttribute(
    "displacement",
    new THREE.BufferAttribute(displacement, 3)
  );
  usedGeo.setAttribute("customColor", new THREE.BufferAttribute(colors, 3));
  usedGeo.setAttribute("faceNormal", new THREE.BufferAttribute(faceNormals, 3));
  usedGeo.setAttribute("planeIndex", new THREE.BufferAttribute(planeIndex, 1));
  usedGeo.setAttribute("origin", new THREE.BufferAttribute(origins.array, 3));

  let uniforms = {
    amplitude: { value: -1 },
  };

  const vertilla = `
uniform float amplitude;

attribute vec3 customColor;
attribute vec3 displacement;
attribute vec3 faceNormal;

attribute int planeIndex;
attribute vec3 origin;



varying vec3 vNormal;
varying vec3 vColor;

void main() {

    vNormal = normal;
    vColor = customColor;
    float fplaneIndex = float(planeIndex);

    vec3 newPosition;
    vec3 originVector = position - origin;
    originVector = normalize(originVector);
    
    newPosition = position + amplitude * faceNormal ;

    // if (fplaneIndex <= amplitude && (amplitude-fplaneIndex <= 115.0)) {
    //   newPosition = position - originVector * (amplitude-fplaneIndex)  ;
    // }
    // else if (amplitude-fplaneIndex > 115.0){
    //   newPosition = position - originVector * 115.0;
    // }
    // else {
    //   newPosition = position;
    // }
    // if (fplaneIndex >= 447.0 && fplaneIndex < 565.0) {
    //   newPosition = position + faceNormal * amplitude * displacement;
    // }
    // else {
    //         newPosition = position + faceNormal * amplitude * displacement;
    // }

    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
}
`;

  const fraglon = `
varying vec3 vNormal;
varying vec3 vColor;

void main() {

    const float ambient = 1.0;

    vec3 light = vec3( 0,-1,0 );
    vec3 light2 = vec3( 0,1,0);

    // light = normalize( light );

    float directional = max( dot( vNormal, light ), 0.0 );
    float directional2 = max( dot( vNormal, light2 ), 0.0 );


    gl_FragColor = vec4( (   directional + directional2 +  ambient ) * vColor, 0.9);


}
`;

  const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertilla,
    fragmentShader: fraglon,
    side: THREE.DoubleSide,
    wireframe: false,
    transparent: true,
  });

  function render() {
    // const time = Date.now() * 0.001;
    // uniforms.amplitude.value = 1.0 + Math.sin(time * 0.5);
  }

  useFrame(() => {
    render();
    TWEEN.update();
  });

  return (
    // <Stage contactShadow={{ resolution: 1024, scale: 10 }}>
    <group onClick={onClick}>
      <mesh
        rotation={[0, Math.PI / 8, 0]}
        ref={mesh}
        // Position Z is offset 100. Origins is z-100;
        geometry={usedGeo}
        material={shaderMaterial}
      ></mesh>
    </group>
    // </Stage>
  );
}
